library(nlme)
library(retrosheet)

ALfinal <- read.table('2009AL.txt', header=T)
NLfinal <- read.table('2009NL.txt', header=T)
ALfinal$Lg <- "AL"
NLfinal$Lg <- "NL"
final <- rbind(ALfinal, NLfinal)
# sort team according to wins
final <- final[order(final$W, decreasing=TRUE), ]
# assign initial rank centered at 0 with random errors
set.seed(20160806)
final$str <- 14.5:-14.5 + rnorm(length(final$Tm), 0, 3)
# sort team according to team name
ALfinal <- final[final$Lg == 'AL', ]
NLfinal <- final[final$Lg == 'NL', ]
ALfinal <- ALfinal[order(ALfinal$Tm), ]
NLfinal <- NLfinal[order(NLfinal$Tm), ]
ind <- grep("MIA", NLfinal$Tm)
NLfinal[length(NLfinal$Tm) + 1, ] <- NLfinal[ind, ]
NLfinal <- NLfinal[-ind, ]
# x-hat0
x0 <- rbind(ALfinal, NLfinal)$str
n <- length(final$Tm)
# sigma-hat0
sigma0 <- sd(x0)
Sig0 <- sigma0*diag(length(teamIds))
sigV <- 1
M <- sigV*diag(n)
sigW <- 1



# C matrix
C1 <- as.matrix(matchSeasons$S2010[matchSeasons$S2010$Date == "2010-04-05", ][, -1:-2])
# D Matrix
D1 <- covSeasons$S2010[covSeasons$S2010$Date == "2010-04-05", ][,c(3,5)]
# y
y1 <- scoreSeasons$S2010[scoreSeasons$S2010$Date == "2010-04-05", ][,3]

# recursive function to calculate sigma
# equation 9 of paper
#Predictive cov matrix, Sigma_t+1|t
sigma_pred <- function(t, season){
  match <- 1
  sigma_post(t - 1, season)
}

# equation 10 of paper
# Posterior cov matrix, Sigma_t+1|t+1 
sigma_post <- function(t, season){
  if(t > 0){
    Ct <- as.matrix(getC(t, season)) # C_t
    mt <- nrow(Ct)  # m: number of games on day t
    Nt <- sigW*diag(mt) # N: 
    sprev <- sigma_pred(t, season)
    return(sprev - 
             sprev%*%t(Ct)%*%
             solve(Ct%*%sprev%*%t(Ct) + Nt)%*%
             Ct%*%sprev)
  }
  else{
    Sig0 + M
  }
}

## test ##
# first game of 2010
sigma_pred(1, 1) # Sig_pred_1|0 = Sig_pred_0|0 + M = Sig0 + M
# second game of 2010
sigma_pred(2, 1) # Sig_pred_2|1
# third game of 2010
sigma_pred(3, 1) # Sig_pred_3|2



# recurssive function to calculate x
# 2.2.4 (ii) of paper
# prediction of system states
x_pred <- function(t, season){
  if(t > 1){
    x_post(t - 1, season)
  }
  else{
    x0
  }
}

u <- matrix(rep(1, 32), ncol=1)
# equation 11 of paper
# posterior estimate of system states
# u is the coeffcients of the covariates
x_post <- function(t, season, u){
  if(t > 1){
    Ct <- as.matrix(getC(t, season)) # C_t
    Dt <- as.matrix(getD(t, season)) # D_t
    mt <- nrow(Ct)  # m: number of games on day t
    Nt <- sigW*diag(mt) # N: 
    xprev <- x_post(t - 1, season) # X-hat_t-1 | t-1
    sigpost <- sigma_post(t, season) # Sigma-hat_t | t
    yt <- as.matrix(gety(t, season)) # y_t, point differentials on games in t-th game day
    return(xprev + (1/sigW)*sigpost%*%t(Ct)%*%(yt - Ct%*%xprev - Dt%*%u))
  }
  else{
    x0
  }
}

## test ##
# first game of 2010
x_post(1, 1, u) # x_1|0 
# second game of 2010
x_post(2, 1, u) # x_2|1
# third game of 2010
x_post(3, 1, u) # x_3|2


# likelihood function 
# equation 21 of the paper
log_like <- function(sig0, sigV, sigW, u){
  season = 1 # 2010 season
  Tot <- length(matchSeasons[[season]]$Tind) # Number of game days
  logLF <- 0
  for(i in 1:Tot){
    Ct <- as.matrix(getC(t, season)) # C_t
    Dt <- as.matrix(getD(t, season)) # D_t
    mt <- nrow(Ct)  # m: number of games on day t
    Nt <- sigW*diag(mt) # N
    yt <- as.matrix(gety(t, season)) # y_t, point differentials on games in t-th game day
    yhat_t <- Ct%*%x_pred(t, season) + Dt%*%u # 2.3.1 of paper
    Ohat_t <- Ct%*%sigma_pred(t, season)%*%t(Ct) + Nt # 2.3.1 of paper
    a <- (-1/2)*log(det(Ohat_t))
    b <- (-1/2)*(t(yt - yhat_t)%*%solve(Ohat_t)%*%(yt - yhat_t))
    logLF_t <- a + b
    logLF <- logLF + logLF_t
  }
  return(-logLF)
}

